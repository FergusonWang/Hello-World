[TOC]

# 1  Github

## 1.1 目的

PAUSE_一是看有没有生产力工具。  

PAUSE_二是看有没有可用的C++和python的中间件资源

三是考虑使用Git的协同开发和代码评审。

## 1.2 经验

### 1.2.1 协同开发

Github中仓库是项目的基本单位，库下面用fork开分支，在分支中进行文件内的修改和文件/目录级的修改。

committing 表示提交的意思，或者说修改后保存到服务器上。

使用主分支作为产品版本，使用其余的分支进行新增功能和bug修复，其余的分支在合适的时候，合并到主分支上去。![branching](C:\Users\Administrator\Desktop\学习笔记\branching.png)

但是



### 1.2.2 使用资源

Github上新的资源可以跟踪GitHubDaily，并可以在知乎跟踪。

使用Github中的开源软件时，一般master是正式的产品版本。

开源软件Open的是源码和文档，后续的Build和部署的问题需要自行解决。





​	

## 1.3 待解决的问题

fork和开branch的区别？fork只是把这个仓库在本人账户下创建一个副本，branch

issue是什么意思？

pull request是什么意思？

pull request后是如何进行代码review的？

branch中能够有目录？

本地如何修改仓库？

clone是什么意思？

能否在本地建立仓库进行版本管理？

#  2 PAUSE_Typora

## 2.1 目的

一是配合Github中md文件的使用。 

二是便于将来编写代码相关的文档。

## 2.2 经验 

Typora的思路是编辑者只考虑内容和框架，排版由解释器完成，而且解释器排版时不能自定义，只能依靠有限的主题并使用菜单选项做调整。由于内容和框架与排版解耦，所以一定要避免用修改内容的方法解决排版问题。在使用office时，也是同样的思路。

md文件本质上类似C文件，可以认为是代码，所以在Typora中编辑不方便时可以用UE按照文本文件编辑。

md是个单纯的代码或文本文件，所以md中的图都是一段代码指定的引用，也就是说类似VS中的图标资源，如果把原本的图片文件删了，md中也就没有了。而word中是对原来图片的复制，这也导致md文件很小，word文件比较大。

md文件本质上是代码，所以可以导出/生成为其余的文档类型，类似相同的源码使用不同的编译器生成不同平台下的可用结果。

使用#设置标题时，#和标题之间要有空格，否则解释器不识别。

标题编号和标题之间使用空格分隔。

行缩进使用全角空格，否则在转PDF时会被删除。推测半角的空格和制表符在Markdown语法中都被删除，全角的制表符同样不认，只有全角空格被认为是文件的字符。

全角空格可以直接复制黏贴。

图片可以直接拖到md文件里，图片如果放在段落首行，也会缩进。

文档中各种的字体和大小，由主题定义。

可以开多个窗口。

PDF：文件-导出-PDF

推测：

makedown适合写笔记这种小型文档，太大型的文档需要频繁修改，还是适合word。

makedown适合写包含代码的文档。



## 2.1 待解决的问题

如何转化为Word？装Pandoc

导出PDF的缩进呢？

word和PDF如何导入？

有序列表如何和段落首行对齐？

有序列表结束后，光标推不到行头。

# 3 Python

## 3.1 目的

用python做工具解决以下问题

1. 在园区网登录软件集成研发平台，跟踪软件单据的审批状态，当发现某个角色由非审批变为审批后，桌面弹窗显示审批意见+剩余的审批角色。没有剩余的审批角色时，显示单据已完成。

   

## 3.2 经验

Python语句没有；，使用换行符来分割语句

Print,而不是printf

Print两次输出之间自动换行，确保输出分行和代码分行一致。

用缩进来代表循环体

For语句后面要加：

数值列表使用的是全局方法

=只是变量赋值和初始化

列表复制使用= [:]，类似memcpy，列表名复制本质是多一个引用

冒号后面要有缩进

## 3.3 待解决的问题



## 3.4 计划



# 4 计算机系统

## 4.1 开发分层

自下向上如何构建一个计算机系统：

硬件层：略。

BSP层：包含编译器模块，调度模块和驱动模块。

编译器模块：向下依赖于CPU，把C/汇编语言转化成CPU的机器码，再由CPU控制接口。向上的接口提供了对C标准语法的支持。

以及在C标准语法基础上实现的C标准库，以及在C基础上实现的对C++等其余语言的支持。在BSP的编译器（特例是C的编译器是由C语言写的，这是因为C最早的编译器是Fortran写的，C之父又用C语言做了重写）。

驱动模块：硬件层除了CPU内核之外全部设备的驱动。一方面依赖于同层的编译器模块，确保源码能够执行，一方面

应用层：包含编译器模块，资源库和用户的应用。

编译器模块：向下依赖于BSP层，

资源库：有两种视图。

用户的应用：根据用户的需求待开发的软件配置项，可以使用同层和下一层全部的模块，也是开发分层视图的立足点。

开发分层的构建过程：

## 4.2 功能分层

功能分层没有编译器模块。

自下向上是

BSP层：下方的平台就是cpu和接口芯片的寄存器，本层开发语言是C语言，编译器是嵌入式（依赖cpu）的C语言编译器。向上提供的

操作系统层：

中间件层：

应用层：













由于编译器的原因，每一层都应该有对应的开发语言，每一层都有各自的编译器。分层模型中，每层都有自己的操作系统和编译器。

分层抽象，分层的描述和具象化。

应用层和资源层的分离，应该是通过虚拟总线+消息队列+事件驱动的中间件。

静态和动态：静态是编译时提供的库，动态是链接时提供的库。

静态就是库提供给上一层的软件，上层软件进行应用开发，例如我们的软件

动态就是下一层的库提供给编译器，上层完全看不见下层，典型就是python
